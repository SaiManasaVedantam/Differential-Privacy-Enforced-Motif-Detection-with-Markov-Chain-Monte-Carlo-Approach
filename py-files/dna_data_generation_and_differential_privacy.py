# -*- coding: utf-8 -*-
"""dna_data_generation_and_differential_privacy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LU4bXX_CQWI-DtNXemIeGj4eAl1Odpz3

# Generating DNA dataset for motif detection & implementing Differential Privacy on data
"""

# Filter warnings
import warnings
warnings.filterwarnings("ignore")

# Import necessary libraries
import time
import random
import matplotlib.pyplot as plt
from google.colab import drive

"""## All necessary functions that deal with data generation, motif positioning, information content extraction, storing results etc. are defined below"""

# Function to generate a random sequence of certain length based on nucleotide probabilities
# Input: sequence_length (Integer), nucleotide_prob (Integer array of size 4)
# Output: sequence (String of length sequence_length)

def generate_sequence(sequence_length, nucleotide_prob):
	sequence = []
  
	for i in range(0, sequence_length):
		random_probability = random.random()
		if random_probability < nucleotide_prob[0]:
			sequence.append(nucleotides[0])
		elif random_probability < nucleotide_prob[0] + nucleotide_prob[1]:
			sequence.append(nucleotides[1])
		elif random_probability < nucleotide_prob[0] + nucleotide_prob[1] + nucleotide_prob[2]:
			sequence.append(nucleotides[2])
		else:
			sequence.append(nucleotides[3])
	 
	return ''.join(sequence)

# Function to plant a randomly chosen motif at a random position in the given sequence
# Input: seq_to_modify (String), motifs (Array of motif Strings), motif_length (Integer), 
# 			 sequence_length (Integer), sequence_count (Integer (Max. no. of motifs available))
# Output: modified_sequence (String which is obtained by inserting randomized_motif in seq_to_modify)

def plant_motifs_in_sequence(seq_to_modify, motifs, motif_length, sequence_length, sequence_count):
	random_plant_position = random.randrange(0, sequence_length - motif_length)
	random_motif_position = random.randrange(0, sequence_count)
	modified_sequence = seq_to_modify[:random_motif_position] + motifs[random_motif_position] + seq_to_modify[random_motif_position + motif_length:]
	
	return modified_sequence, random_motif_position

# Function to generate sequence_count no. of random sequences of size sequence_length
# Input: sequence_count (Integer), sequence_length (Integer), nucleotide_prob (List)
# Output: sequences (List of sequence_count no. of sequences each of sequence_length size)
#         generation_time (Float describing the time taken to generate sequences)

def generate_sequences_of_given_count(sequence_count, sequence_length, nucleotide_prob):
  start_time = time.perf_counter()
  sequences = []
  
  for count in range(0, sequence_count):
    generated_sequence = generate_sequence(sequence_length, nucleotide_prob)
    sequences.append(generated_sequence)
  print("\nNo. of sequences: ", len(sequences))  
  print("A sample sequence looks like: ", sequences[0])
  end_time = time.perf_counter()
  generation_time = round(end_time - start_time, 2)

  return sequences, generation_time

# Function to read data from icpc_p_map.txt to get the probability associated with the Information Content Per Column (ICPC)
# Input: file_path (String)
# Output: icpc_prob (List containing icpc info)

def obtain_info_content_per_column(file_path):
  
  # Open given file and store the file_ptr
  file_ptr = open(file_path, "r")
  icpc_prob = []
  header_line = False

  for each_line in file_ptr:
    if header_line == False:
      header_line = True
      continue
    line = each_line.strip().split()
    line = [float(x) for x in line]
    icpc_prob.append(line)
  file_ptr.close()
  
  return icpc_prob

# Function to save modified sequences, motif positions, random motif and profile matrix to respective files
# Input: sequence_count (Integer), modified_sequences (List), random_positions (List), profile_matrix (List)
# Output: Does not return anything but saves data to respective files

def save_results_to_respective_files(sequence_count, modified_sequences, random_positions, profile_matrix):

  # Write modified sequences to differential_privacy_enforced_sequences.txt file
  file_path = base_path + "/Data/differential_privacy_enforced_sequences_" + str(sequence_count) + ".txt"
  file_ptr = open(file_path, "w")
  for i in range(0, sequence_count):
    file_ptr.write("seq_" + str(i+1) + "\n" + modified_sequences[i] + "\n")
  file_ptr.close()

  # Write planted motif positions to motif_positions.txt file
  file_path = base_path + "/Data/motif_positions_" + str(sequence_count) + ".txt"
  file_ptr = open(file_path, "w")
  for i in range(0, sequence_count):
    file_ptr.write(str(random_positions[i]) + "\n")
  file_ptr.close()

  # Write the initially generated random motif and its corresponsding profile matrix to a file
  file_path = base_path + "/Data/random_motif.txt"
  file_ptr = open(file_path, "w")
  file_ptr.write(">" + random_motif + "\t of length " + str(motif_length) + "\n")
  for i in range(0, len(profile_matrix)):
    for j in range(0, len(profile_matrix[0])):
      file_ptr.write(str(profile_matrix[i][j]) + "\t")
    file_ptr.write("\n")
  file_ptr.write("<")
  file_ptr.close()

"""## Performing actual data genaration for further use"""

# Establish connection to use Google drive
drive.mount("/content/drive")
base_path = "drive/MyDrive/DNA-Dataset"

# Define constants needed
nucleotides = ['A', 'G', 'T', 'C']
nucleotide_prob = [0.25, 0.25, 0.25, 0.25]

# ICPC: information_content_per_column = float(input()) # [0, 2]
# Typically rounded down to two decimal digits
icpc = 1.02 

# Generally 5-20 base pairs long
motif_length = 40 

# General length of a dna sequence is 150 base pairs
sequence_length = 300

# For analysis, we generate different no. of dna sequences
sequence_counts = [1000, 5000, 10000, 50000, 100000]

# For analysis, we store sequence generation times for various length 
sequence_generation_times = []

# Obtain probability associated with information content per column
icpc_path = base_path + "/icpc_p_map.txt"
icpc_prob = obtain_info_content_per_column(icpc_path)
icpc_probability = [icpc_prob[i][1] for i in range(0, len(icpc_prob)) if round(icpc, 2) == icpc_prob[i][0]]
icpc_probability = icpc_probability[0]

# Obtain normalized probabilities by performing (1 - prob) / (1 + max_icpc)
normalized_prob = (1 - icpc_probability) / 3.0

# Generate a random motif and save it to random_motif.txt
random_motif = generate_sequence(motif_length, nucleotide_prob)

# Generate DNA sequences of different sequence counts
for sequence_count in sequence_counts:

  # Start the timer to track generation times
  start_time = time.perf_counter()
  
  # Generate sequences of given sequence count
  sequences = []
  for i in range(0, sequence_count):
    seq = generate_sequence(sequence_length, nucleotide_prob)
    sequences.append(seq)

  # Generate motif_length no. of random motifs of size sequence_count using
  # the previously generated random motif to re-assign probability values
  generated_motifs = []
  for i in range(0, motif_length):
    motif_prob = [normalized_prob, normalized_prob, normalized_prob, normalized_prob]
    for j in range(0, len(nucleotides)):
      if random_motif[i] == nucleotides[j]:
        motif_prob[j] = icpc_probability
    generated_motif = generate_sequence(sequence_count, motif_prob)
    generated_motifs.append(generated_motif)

  # Generate sequence_count no. of random motifs of size motif_length
  motifs = []
  for i in range(0, sequence_count):
    motif = []
    for j in range(0, motif_length):
      motif.append(generated_motifs[j][i])
    motifs.append(''.join(motif))

  print("\nNo. of motifs: ", len(motifs))
  print("A motif looks like: ", motifs[0])

  # Constructing the Positional Weight Matrix or Profile Matrix
  # to analyze the counts associated with nucleotides
  profile_matrix = []
  for i in range(0, motif_length):
    counts = [0, 0, 0, 0]
    for j in range(0, sequence_count):
      for k in range(0, len(nucleotides)):
        if motifs[j][i] == nucleotides[k]:
          counts[k] = counts[k] + 1
    profile_matrix.append(counts)

  print("\nNo. of rows in profile_matrix: ", len(profile_matrix))
  print("No. of columns in profile matrix: ", len(profile_matrix[0]))
  print("A sample row in profile matrix looks like: ", profile_matrix[0], "\n")

  # Plant as many motifs as sequence_count in sequences to enforce differential privacy
  modified_sequences = []
  random_positions = []
  for i in range(0, sequence_count):
    modified_sequence, random_position = plant_motifs_in_sequence(sequences[i], motifs, motif_length, sequence_length, sequence_count)
    modified_sequences.append(modified_sequence)
    random_positions.append(random_position)

  # Save results to respective files
  save_results_to_respective_files(sequence_count, modified_sequences, random_positions, profile_matrix)

  # End the timer to stop and save the total generation time
  end_time = time.perf_counter()
  sequence_generation_times.append(round(end_time - start_time, 2))
  print("**********************************")

"""## Visualizing the relation between sequence count and generation times"""

# Plot the generation times and sequence_count  to visualize data generation times
plt.plot(sequence_generation_times, sequence_counts)
plt.xlabel('Sequence Generation Time (in seconds)')
plt.ylabel('Sequence Count')
plt.title('Visualizing the effect of sequence count on generation times')
plt.show()