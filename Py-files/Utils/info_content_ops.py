# -*- coding: utf-8 -*-
"""info_content_ops.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wCgTFWmkTqTaVro7QsiYhepQ_j_1lEvV

### This notebook defines function to read and compute information content values
"""

# Import necessary packages
import numpy as np
import math

# Function to predict the motif_site in ignored sequence using the Position Weight Matrix
# Input: motif_sites, dna_seqeunces, motif_length, no_of_seqs, pwm
# Output: Returns information content and updated pwm

def compute_information_content(nucleotides, freq, motif_sites, dna_seqs, motif_len, no_of_seqs, precomputed_pwm):
  
  # Calculating the PWM
  # Rows: 4 representing A, G, T, C respectively
  # Columns: As many as the motif length
  updated_pwm = np.zeros((4, motif_len))
  
  # Indexing the N-1 sequences
  idx = 0

  # Computing updated PWM
  for seq_idx in range(0, no_of_seqs):
    for m_len in range(0, motif_len):
      value = dna_seqs[seq_idx][motif_sites[idx] + m_len]
      if value == nucleotides[0]:
        updated_pwm[0][m_len] += 1
      elif value == nucleotides[1]:
        updated_pwm[1][m_len] += 1
      elif value == nucleotides[2]:
        updated_pwm[2][m_len] += 1
      elif value == nucleotides[3]:
        updated_pwm[3][m_len] += 1
    idx += 1
  updated_pwm = updated_pwm / no_of_seqs

  # Finding the information content based on the updated PWM
  info_content = 0
  for m_len in range(0, motif_len):
    for nuc_no in range(0, 4):
      if nuc_no == 0:
        normalized_pwm = updated_pwm[nuc_no][m_len] / freq[0]
      elif nuc_no == 1:
        normalized_pwm = updated_pwm[nuc_no][m_len] / freq[1]
      elif nuc_no == 2:
        normalized_pwm = updated_pwm[nuc_no][m_len] / freq[2]
      elif nuc_no == 3:
        normalized_pwm = updated_pwm[nuc_no][m_len] / freq[3]
      if normalized_pwm == 0:
        continue
      info_content += updated_pwm[nuc_no][m_len] * math.log(normalized_pwm, 2)

  return info_content, updated_pwm

# Function to read data from icpc_p_map.txt to get the probability associated with the Information Content Per Column (ICPC)
# Input: file_path (String)
# Output: icpc_prob (List containing icpc info)

def obtain_info_content_per_column(file_path):
  
  # Open given file and store the file_ptr
  file_ptr = open(file_path, "r")
  icpc_prob = []
  header_line = False

  for each_line in file_ptr:
    if header_line == False:
      header_line = True
      continue
    line = each_line.strip().split()
    line = [float(x) for x in line]
    icpc_prob.append(line)
  file_ptr.close()
  
  return icpc_prob